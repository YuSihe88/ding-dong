"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PuppetServer = void 0;
const util_1 = __importDefault(require("util"));
const wechaty_puppet_1 = require("wechaty-puppet");
const wechaty_grpc_1 = require("wechaty-grpc");
const config_js_1 = require("../config.js");
const puppet_implementation_js_1 = require("./puppet-implementation.js");
const mod_js_1 = require("../auth/mod.js");
const ca_js_1 = require("../auth/ca.js");
class PuppetServer {
    constructor(options) {
        this.options = options;
        wechaty_puppet_1.log.verbose('PuppetServer', 'constructor({endpoint: "%s", puppet: "%s", token: "%s"})', options.endpoint, options.puppet, options.token);
    }
    version() {
        return config_js_1.VERSION;
    }
    async start() {
        wechaty_puppet_1.log.verbose('PuppetServer', 'start()');
        if (this.grpcServer) {
            throw new Error('grpc server existed!');
        }
        const puppetImpl = (0, puppet_implementation_js_1.puppetImplementation)(this.options.puppet);
        const puppetImplAuth = (0, mod_js_1.authImplToken)(this.options.token)(puppetImpl);
        this.grpcServer = new wechaty_grpc_1.grpc.Server(config_js_1.GRPC_OPTIONS);
        this.grpcServer.addService(wechaty_grpc_1.puppet.PuppetService, puppetImplAuth);
        const caCerts = config_js_1.envVars.WECHATY_PUPPET_SERVICE_TLS_CA_CERT();
        const caCertBuf = caCerts
            ? Buffer.from(caCerts)
            : null;
        const certChain = Buffer.from(config_js_1.envVars.WECHATY_PUPPET_SERVICE_TLS_SERVER_CERT(this.options.tls?.serverCert)
            || ca_js_1.TLS_INSECURE_SERVER_CERT);
        const privateKey = Buffer.from(config_js_1.envVars.WECHATY_PUPPET_SERVICE_TLS_SERVER_KEY(this.options.tls?.serverKey)
            || ca_js_1.TLS_INSECURE_SERVER_KEY);
        const keyCertPairs = [{
                cert_chain: certChain,
                private_key: privateKey,
            }];
        /**
         * Huan(202108): for maximum compatible with the non-tls community servers/clients,
         *  we introduced the WECHATY_PUPPET_SERVICE_NO_TLS_INSECURE_{SERVER,CLIENT} environment variables.
         *  if it has been set, then we will run under HTTP instead of HTTPS
         */
        let credential;
        if (config_js_1.envVars.WECHATY_PUPPET_SERVICE_NO_TLS_INSECURE_SERVER(this.options.tls?.disable)) {
            wechaty_puppet_1.log.warn('PuppetServer', 'start() TLS disabled: INSECURE!');
            credential = wechaty_grpc_1.grpc.ServerCredentials.createInsecure();
        }
        else {
            wechaty_puppet_1.log.verbose('PuppetServer', 'start() TLS enabled.');
            credential = wechaty_grpc_1.grpc.ServerCredentials.createSsl(caCertBuf, keyCertPairs);
        }
        /***
         * Start Grpc Server
         */
        const port = await util_1.default.promisify(this.grpcServer.bindAsync.bind(this.grpcServer))(this.options.endpoint, credential);
        if (port === 0) {
            throw new Error('grpc server bind fail!');
        }
        this.grpcServer.start();
    }
    async stop() {
        wechaty_puppet_1.log.verbose('PuppetServer', 'stop()');
        if (!this.grpcServer) {
            throw new Error('no grpc server');
        }
        await util_1.default.promisify(this.grpcServer.tryShutdown
            .bind(this.grpcServer))();
        const grpcServer = this.grpcServer;
        setImmediate(() => grpcServer.forceShutdown());
        this.grpcServer = undefined;
    }
}
exports.PuppetServer = PuppetServer;
//# sourceMappingURL=puppet-server.js.map