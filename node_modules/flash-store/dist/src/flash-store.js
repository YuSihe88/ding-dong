"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashStore = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const app_root_path_1 = __importDefault(require("app-root-path"));
const rimraf_1 = __importDefault(require("rimraf"));
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const config_1 = require("./config");
class FlashStore {
    /**
     * FlashStore is a Key-Value database tool and makes using leveldb more easy for Node.js
     *
     * Creates an instance of FlashStore.
     * @param {string} [workdir=path.join(appRoot, 'flash-store.workdir')]
     * @example
     * import { FlashStore } from 'flash-store'
     * const flashStore = new FlashStore('flashstore.workdir')
     */
    constructor(workdir = path_1.default.join(app_root_path_1.default.path, '.flash-store')) {
        this.workdir = workdir;
        if (fs_1.default.existsSync(this.workdir)) {
            config_1.log.verbose('FlashStore', 'constructor(%s)', workdir);
        }
        else {
            /**
              * Mkdir for the database directory. (only for the last path, no recursive)
              */
            config_1.log.silly('FlashStore', 'constructor(%s) not exist, creating...', this.workdir);
            try {
                fs_1.default.mkdirSync(this.workdir);
            }
            catch (e) {
                config_1.log.error('FlashStore', 'constructor(%s) exception: %s', this.workdir, e && e.message);
                throw e;
            }
            config_1.log.silly('FlashStore', 'constructor(%s) workdir created.', this.workdir);
        }
        // we use seperate workdir for snapdb, leveldb, and rocksdb etc.
        const sqliteFile = path_1.default.join(this.workdir, 'sqlite.db');
        this.flashSqlite = this.initSqlite(sqliteFile);
    }
    initSqlite(file) {
        config_1.log.verbose('FlashStore', 'initSqlite(%s)', file);
        const db = new better_sqlite3_1.default(file);
        const sql = `
      CREATE TABLE IF NOT EXISTS store (
        key TEXT NOT NULL,
        val TEXT NOT NULL,
        PRIMARY KEY(key)
      ) WITHOUT ROWID;
    `;
        db.exec(sql);
        const onExitClose = () => db && db.open && db.close();
        process.on('exit', onExitClose);
        const stmtCount = db.prepare('SELECT COUNT(*) FROM store').pluck();
        const stmtDel = db.prepare('DELETE FROM store WHERE key = ?');
        const stmtDelAll = db.prepare('DELETE FROM store');
        const stmtGet = db.prepare('SELECT val FROM store WHERE key = ?').pluck();
        const stmtSet = db.prepare(`
      INSERT INTO store (key, val)
      VALUES ($key, $val)
      ON CONFLICT(key) DO UPDATE SET val = $val
    `);
        const stmtIterate = db.prepare('SELECT key, val FROM store').raw();
        return {
            db,
            stmtCount,
            stmtDel,
            stmtDelAll,
            stmtGet,
            stmtIterate,
            stmtSet,
        };
    }
    version() {
        return config_1.VERSION;
    }
    /**
     * Set data in database
     *
     * @param {K} key
     * @param {V} value
     * @returns {Promise<void>}
     * @example
     * await flashStore.set(1, 1)
     */
    set(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'set(%s, %s) value type: %s', key, JSON.stringify(value), typeof value);
            // await this.db.put(key, JSON.stringify(value))
            const result = this.flashSqlite.stmtSet.run({
                key,
                val: JSON.stringify(value),
            });
            if (result.changes !== 1) {
                throw new Error('set fail!');
            }
            return this;
        });
    }
    /**
     * Get value from database by key
     *
     * @param {K} key
     * @returns {(Promise<V | null>)}
     * @example
     * console.log(await flashStore.get(1))
     */
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'get(%s)', key);
            const value = this.flashSqlite.stmtGet.get(key);
            return value && JSON.parse(value);
        });
    }
    /**
     * Del data by key
     *
     * @param {K} key
     * @returns {Promise<void>}
     * @example
     * await flashStore.delete(1)
     */
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'delete(%s)', key);
            this.flashSqlite.stmtDel.run(key);
            return true;
        });
    }
    /**
     * @typedef IteratorOptions
     *
     * @property { any }      gt       - Matches values that are greater than a specified value
     * @property { any }      gte      - Matches values that are greater than or equal to a specified value.
     * @property { any }      lt       - Matches values that are less than a specified value.
     * @property { any }      lte      - Matches values that are less than or equal to a specified value.
     * @property { boolean }  reverse  - Reverse the result set
     * @property { number }   limit    - Limits the number in the result set.
     * @property { any }      prefix   - Make the same prefix key get together.
     */
    /**
     * Find keys by IteratorOptions
     *
     * @param {IteratorOptions} [options={}]
     * @returns {AsyncIterableIterator<K>}
     * @example
     * const flashStore = new FlashStore('flashstore.workdir')
     * for await(const key of flashStore.keys({gte: 1})) {
     *   console.log(key)
     * }
     */
    keys(options = {}) {
        return __asyncGenerator(this, arguments, function* keys_1() {
            var e_1, _a;
            config_1.log.verbose('FlashStore', 'keys()');
            // options = Object.assign(options, {
            //   keys   : true,
            //   values : false,
            // })
            if (options.prefix) {
                if (options.gte || options.lte) {
                    throw new Error('can not specify `prefix` with `gte`/`lte` together.');
                }
                options.gte = options.prefix;
                options.lte = options.prefix + '\xff';
            }
            try {
                for (var _b = __asyncValues(this.entries(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [key] = _c.value;
                    yield yield __await(key);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Find all values
     *
     * @returns {AsyncIterableIterator<V>}
     * @example
     * const flashStore = new FlashStore('flashstore.workdir')
     * for await(const value of flashStore.values()) {
     *   console.log(value)
     * }
     */
    values(options = {}) {
        return __asyncGenerator(this, arguments, function* values_1() {
            var e_2, _a;
            config_1.log.verbose('FlashStore', 'values()');
            try {
                // options = Object.assign(options, {
                //   keys   : false,
                //   values : true,
                // })
                for (var _b = __asyncValues(this.entries(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [, value] = _c.value;
                    yield yield __await(value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the size of the database
     * @returns {Promise<number>}
     * @example
     * const size = await flashStore.size
     * console.log(`database size: ${size}`)
     */
    get size() {
        config_1.log.verbose('FlashStore', 'size()');
        const num = this.flashSqlite.stmtCount.get();
        return Promise.resolve(num);
    }
    /**
     */
    has(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const val = yield this.get(key);
            return !!val;
        });
    }
    /**
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flashSqlite.stmtDelAll.run();
        });
    }
    /**
     * @private
     */
    entries(options) {
        return __asyncGenerator(this, arguments, function* entries_1() {
            config_1.log.verbose('FlashStore', '*entries(%s)', JSON.stringify(options));
            for (const [key, val] of this.flashSqlite.stmtIterate.iterate()) {
                yield yield __await([key, JSON.parse(val)]);
            }
        });
    }
    forEach(callbackfn, thisArg) {
        var e_3, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _b = __asyncValues(this.entries()), _c; _c = yield _b.next(), !_c.done;) {
                    const [key, value] = _c.value;
                    callbackfn.call(thisArg, value, key, this);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            config_1.log.verbose('FlashStore', '*[Symbol.asyncIterator]()');
            yield __await(yield* __asyncDelegator(__asyncValues(this.entries())));
        });
    }
    /**
     * FlashStore will not be able to be used anymore after it has been closed.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'close()');
            yield this.flashSqlite.db.close();
        });
    }
    /**
     * Destroy the database
     *
     * @returns {Promise<void>}
     */
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'destroy()');
            yield this.close();
            yield new Promise(resolve => rimraf_1.default(this.workdir, resolve));
        });
    }
}
exports.FlashStore = FlashStore;
FlashStore.VERSION = config_1.VERSION;
exports.default = FlashStore;
//# sourceMappingURL=flash-store.js.map