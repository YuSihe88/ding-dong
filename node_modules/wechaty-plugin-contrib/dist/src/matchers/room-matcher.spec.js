#!/usr/bin/env ts-node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = __importDefault(require("tstest"));
const room_matcher_1 = require("./room-matcher");
tstest_1.default('roomMatcher() smoke testing', async (t) => {
    const matcher = room_matcher_1.roomMatcher(/test/i);
    t.equal(typeof matcher, 'function', 'should return a match function');
});
tstest_1.default('roomMatcher() with string option', async (t) => {
    const TEXT_OK = 'hello';
    const TEXT_NOT_OK = 'world';
    const topicOk = () => TEXT_OK;
    const topicNotOk = () => TEXT_NOT_OK;
    const roomIdOk = {
        id: TEXT_OK,
        topic: topicNotOk,
    };
    const roomTopicOk = {
        id: TEXT_NOT_OK,
        topic: topicOk,
    };
    const roomNotOk = {
        id: TEXT_NOT_OK,
        topic: topicNotOk,
    };
    const falseMatcher = room_matcher_1.roomMatcher();
    t.false(await falseMatcher(roomIdOk), 'should not match any room without options');
    t.false(await falseMatcher(roomTopicOk), 'should not match any room without options');
    const idMatcher = room_matcher_1.roomMatcher(TEXT_OK);
    t.false(await idMatcher(roomNotOk), 'should not match unexpected room by id');
    t.true(await idMatcher(roomIdOk), 'should match expected room by id');
    t.false(await idMatcher(roomTopicOk), 'should not match room by topic');
    const idListMatcher = room_matcher_1.roomMatcher([TEXT_OK]);
    t.false(await idListMatcher(roomNotOk), 'should not match unexpected room by id list');
    t.true(await idListMatcher(roomIdOk), 'should match expected room by id list');
    t.false(await idListMatcher(roomTopicOk), 'should not match room by topic list');
    const regexpMatcher = room_matcher_1.roomMatcher(new RegExp(TEXT_OK));
    t.false(await regexpMatcher(roomNotOk), 'should not match unexpected room by regexp');
    t.false(await regexpMatcher(roomIdOk), 'should match room id by regexp');
    t.true(await regexpMatcher(roomTopicOk), 'should match expected room topic by regexp');
    const regexpListMatcher = room_matcher_1.roomMatcher([new RegExp(TEXT_OK)]);
    t.false(await regexpListMatcher(roomNotOk), 'should not match unexpected room by regexp list');
    t.false(await regexpListMatcher(roomIdOk), 'should not match room id by regexp list');
    t.true(await regexpListMatcher(roomTopicOk), 'should match expected room topic by regexp list');
    const roomFilter = (room) => [
        room.id,
        room.topic(),
    ].includes(TEXT_OK);
    const functionMatcher = room_matcher_1.roomMatcher(roomFilter);
    t.false(await functionMatcher(roomNotOk), 'should not match unexpected room by function');
    t.true(await functionMatcher(roomTopicOk), 'should match expected topic by function');
    t.true(await functionMatcher(roomIdOk), 'should match expected id by function');
    const functionListMatcher = room_matcher_1.roomMatcher([roomFilter]);
    t.false(await functionListMatcher(roomNotOk), 'should not match unexpected room by function list');
    t.true(await functionListMatcher(roomTopicOk), 'should match expected topic by function list');
    t.true(await functionListMatcher(roomIdOk), 'should match expected text by function list');
});
//# sourceMappingURL=room-matcher.spec.js.map