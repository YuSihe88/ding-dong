/**
 *   Wechaty - https://github.com/chatie/wechaty
 *
 *   @copyright 2016-2018 Huan LI <zixia@zixia.net>
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
import path from 'path';
import { FileBox, ImageType, MessageType, ContactType, ContactGender, PayloadType, Puppet, ScanStatus, log, throwUnsupportedError, } from 'wechaty-puppet';
import { CHATIE_OFFICIAL_ACCOUNT_QRCODE, MEMORY_SLOT, qrCodeForChatie, VERSION, } from './config.js';
import { getWhatsApp, } from './whatsapp.js';
class PuppetWhatsapp extends Puppet {
    constructor(options = {}) {
        super(options);
        this.options = options;
        log.verbose('PuppetWhatsApp', 'constructor()');
        this.messageStore = {};
        this.contactStore = {};
    }
    async start() {
        log.verbose('PuppetWhatsApp', 'start()');
        if (this.state.on()) {
            log.warn('PuppetWhatsApp', 'start() is called on a ON puppet. await ready(on) and return.');
            await this.state.ready('on');
            return;
        }
        this.state.on('pending');
        const session = await this.memory.get(MEMORY_SLOT);
        const whatsapp = await getWhatsApp(session);
        this.whatsapp = whatsapp;
        this.initWhatsAppEvents(whatsapp);
        /**
         * Huan(202102): initialize() will rot be resolved not before bot log in
         */
        whatsapp
            .initialize()
            .then(() => log.verbose('PuppetWhatsApp', 'start() whatsapp.initialize() done'))
            .catch(e => {
            if (this.state.on()) {
                console.error(e);
                log.error('PuppetWhatsApp', 'start() whatsapp.initialize() rejection: %s', e);
            }
            else {
                // Puppet is stoping...
                log.verbose('PuppetWhatsApp', 'start() whatsapp.initialize() rejected on a stopped puppet.');
            }
        });
        await super.start();
        /**
         * Huan(202102): Wait for Puppeteer to be inited before resolve start() for robust state management
         */
        const future = new Promise(resolve => {
            function check() {
                if (whatsapp.pupBrowser) {
                    resolve();
                }
                else {
                    // process.stdout.write('.')
                    setTimeout(check, 100);
                }
            }
            check();
        });
        await Promise.race([
            future,
            this.state.ready('off'),
        ]);
    }
    async stop() {
        log.verbose('PuppetWhatsApp', 'stop()');
        if (this.state.off()) {
            log.warn('PuppetWhatsApp', 'stop() is called on a OFF puppet. await ready(off) and return.');
            await this.state.ready('off');
            return;
        }
        if (!this.whatsapp) {
            log.error('PuppetWhatsApp', 'stop() this.whatsapp is undefined!');
            return;
        }
        this.state.off('pending');
        if (this.loopTimer) {
            clearInterval(this.loopTimer);
        }
        try {
            if (this.logonoff()) {
                await this.logout();
            }
            await this.whatsapp.destroy();
            await super.stop();
        }
        finally {
            this.whatsapp = undefined;
            this.state.off(true);
        }
    }
    initWhatsAppEvents(whatsapp) {
        log.verbose('PuppetwhatsApp', 'initWhatsAppEvents()');
        whatsapp.on('authenticated', async (session) => {
            try {
                // save session file
                await this.memory.set(MEMORY_SLOT, session);
                await this.memory.save();
            }
            catch (e) {
                console.error(e);
                log.error('PuppetWhatsApp', 'getClient() whatsapp.on(authenticated) rejection: %s', e);
            }
        });
        whatsapp.on('ready', async () => {
            this.id = whatsapp.info.wid.user;
            this.state.on(true);
            const contacts = await whatsapp.getContacts();
            for (const contact of contacts) {
                this.contactStore[contact.id._serialized] = contact;
            }
            this.emit('login', { contactId: whatsapp.info.wid._serialized });
        });
        whatsapp.on('message', (msg) => {
            const id = msg.id.id;
            this.messageStore[id] = msg;
            this.emit('message', { messageId: msg.id.id });
        });
        whatsapp.on('qr', (qr) => {
            // NOTE: This event will not be fired if a session is specified.
            // console.log('QR RECEIVED', qr);
            this.emit('scan', { qrcode: qr, status: ScanStatus.Waiting });
        });
    }
    // login (contactId: string): Promise<void> {
    //   log.verbose('PuppetWhatsApp', 'login()')
    //   return super.login(contactId)
    // }
    // async logout (): Promise<void> {
    //   log.verbose('PuppetWhatsApp', 'logout()')
    //   if (!this.id) {
    //     throw new Error('logout before login?')
    //   }
    //   this.emit('logout', { contactId: this.id, data: 'test' }) // before we will throw above by logonoff() when this.user===undefined
    //   this.id = undefined
    //   // TODO: do the logout job
    // }
    ding(data) {
        log.silly('PuppetWhatsApp', 'ding(%s)', data || '');
        setTimeout(() => this.emit('dong', { data: data || '' }), 1000);
    }
    unref() {
        log.verbose('PuppetWhatsApp', 'unref()');
        super.unref();
        if (this.loopTimer) {
            this.loopTimer.unref();
        }
    }
    /**
     *
     * ContactSelf
     *
     *
     */
    async contactSelfQRCode() {
        log.verbose('PuppetWhatsApp', 'contactSelfQRCode()');
        return CHATIE_OFFICIAL_ACCOUNT_QRCODE;
    }
    async contactSelfName(name) {
        log.verbose('PuppetWhatsApp', 'contactSelfName(%s)', name);
    }
    async contactSelfSignature(signature) {
        log.verbose('PuppetWhatsApp', 'contactSelfSignature(%s)', signature);
    }
    async contactAlias(contactId, alias) {
        log.verbose('PuppetWhatsApp', 'contactAlias(%s, %s)', contactId, alias);
        if (typeof alias === 'undefined') {
            return 'mock alias';
        }
    }
    async contactPhone(contactId, phoneList) {
        log.verbose('PuppetWhatsApp', 'contactPhone(%s, %s)', contactId, phoneList);
        if (typeof phoneList === 'undefined') {
            return [];
        }
    }
    async contactCorporationRemark(contactId, corporationRemark) {
        log.verbose('PuppetWhatsApp', 'contactCorporationRemark(%s, %s)', contactId, corporationRemark);
    }
    async contactDescription(contactId, description) {
        log.verbose('PuppetWhatsApp', 'contactDescription(%s, %s)', contactId, description);
    }
    async contactList() {
        log.verbose('PuppetWhatsApp', 'contactList()');
        return [];
    }
    async contactQRCode(contactId) {
        log.verbose('PuppetWhatsApp', 'contactQRCode(%s)', contactId);
        if (contactId !== this.selfId()) {
            throw new Error('can not set avatar for others');
        }
        throw new Error('not supported');
        // return await this.bridge.WXqr
    }
    async contactAvatar(contactId, file) {
        log.verbose('PuppetWhatsApp', 'contactAvatar(%s)', contactId);
        /**
         * 1. set
         */
        if (file) {
            return;
        }
        /**
         * 2. get
         */
        const WECHATY_ICON_PNG = path.resolve('../../docs/images/wechaty-icon.png');
        return FileBox.fromFile(WECHATY_ICON_PNG);
    }
    async contactRawPayloadParser(whatsAppPayload) {
        let type, name;
        if (whatsAppPayload.isUser) {
            type = ContactType.Individual;
        }
        else if (whatsAppPayload.isEnterprise) {
            type = ContactType.Corporation;
        }
        else {
            type = ContactType.Unknown;
        }
        if (whatsAppPayload.name === undefined) {
            name = '';
        }
        else {
            name = whatsAppPayload.name;
        }
        return {
            avatar: await whatsAppPayload.getProfilePicUrl(),
            gender: ContactGender.Unknown,
            id: whatsAppPayload.id.user,
            name: name,
            phone: [whatsAppPayload.number],
            type: type,
        };
    }
    async contactRawPayload(id) {
        log.verbose('PuppetWhatsApp', 'contactRawPayload(%s)', id);
        return this.contactStore[id];
    }
    /**
     *
     * Conversation
     *
     */
    async conversationReadMark(conversationId, hasRead) {
        log.verbose('PuppetWhatsApp', 'conversationReadMark(%s, %s)', conversationId, hasRead);
        return throwUnsupportedError();
    }
    /**
     *
     * Message
     *
     */
    async messageContact(messageId) {
        log.verbose('PuppetWhatsApp', 'messageContact(%s)', messageId);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof ContactMock) {
        //   return attachment.id
        // }
        return '';
    }
    async messageImage(messageId, imageType) {
        log.verbose('PuppetWhatsApp', 'messageImage(%s, %s[%s])', messageId, imageType, ImageType[imageType]);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof FileBox) {
        //   return attachment
        // }
        return FileBox.fromQRCode('fake-qrcode');
    }
    async messageRecall(messageId) {
        log.verbose('PuppetWhatsApp', 'messageRecall(%s)', messageId);
        return false;
    }
    async messageFile(id) {
        // const attachment = this.mocker.MockMessage.loadAttachment(id)
        // if (attachment instanceof FileBox) {
        //   return attachment
        // }
        return FileBox.fromBase64('cRH9qeL3XyVnaXJkppBuH20tf5JlcG9uFX1lL2IvdHRRRS9kMMQxOPLKNYIzQQ==', 'mock-file' + id + '.txt');
    }
    async messageUrl(messageId) {
        log.verbose('PuppetWhatsApp', 'messageUrl(%s)', messageId);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof UrlLink) {
        //   return attachment.payload
        // }
        return {
            title: 'mock title for ' + messageId,
            url: 'https://mock.url',
        };
    }
    async messageMiniProgram(messageId) {
        log.verbose('PuppetWhatsApp', 'messageMiniProgram(%s)', messageId);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof MiniProgram) {
        //   return attachment.payload
        // }
        return {
            title: 'mock title for ' + messageId,
        };
    }
    async messageRawPayloadParser(whatsAppPayload) {
        return {
            fromId: whatsAppPayload.from,
            id: whatsAppPayload.id.id,
            mentionIdList: whatsAppPayload.mentionedIds,
            text: whatsAppPayload.body,
            timestamp: Date.now(),
            toId: whatsAppPayload.to,
            type: MessageType.Text,
        };
    }
    async messageRawPayload(id) {
        log.verbose('PuppetWhatsApp', 'messageRawPayload(%s)', id);
        return this.messageStore[id];
    }
    async messageSend(conversationId, something) {
        log.verbose('PuppetWhatsApp', 'messageSend(%s, %s)', conversationId, something);
        if (!this.id) {
            throw new Error('no this.id');
        }
        if (typeof something !== 'string') {
            return;
        }
        if (!this.whatsapp) {
            log.warn('PuppetWhatsApp', 'messageSend() this.client not found');
            return;
        }
        await this.whatsapp.sendMessage(conversationId, something);
        // const user = this.mocker.ContactMock.load(this.id)
        // let conversation
        // if (/@/.test(conversationId)) {
        //   // FIXME: extend a new puppet method messageRoomSendText, etc, for Room message?
        //   conversation = this.mocker.RoomMock.load(conversationId)
        // } else {
        //   conversation = this.mocker.ContactMock.load(conversationId)
        // }
        // user.say(something).to(conversation)
    }
    async messageSendText(conversationId, text) {
        return this.messageSend(conversationId, text);
    }
    async messageSendFile(conversationId, file) {
        return this.messageSend(conversationId, file);
    }
    async messageSendContact(conversationId, contactId) {
        log.verbose('PuppetWhatsApp', 'messageSendUrl(%s, %s)', conversationId, contactId);
        // const contact = this.mocker.MockContact.load(contactId)
        // return this.messageSend(conversationId, contact)
    }
    async messageSendUrl(conversationId, urlLinkPayload) {
        log.verbose('PuppetWhatsApp', 'messageSendUrl(%s, %s)', conversationId, JSON.stringify(urlLinkPayload));
        // const url = new UrlLink(urlLinkPayload)
        // return this.messageSend(conversationId, url)
    }
    async messageSendMiniProgram(conversationId, miniProgramPayload) {
        log.verbose('PuppetWhatsApp', 'messageSendMiniProgram(%s, %s)', conversationId, JSON.stringify(miniProgramPayload));
        // const miniProgram = new MiniProgram(miniProgramPayload)
        // return this.messageSend(conversationId, miniProgram)
    }
    async messageForward(conversationId, messageId) {
        log.verbose('PuppetWhatsApp', 'messageForward(%s, %s)', conversationId, messageId);
    }
    /**
     *
     * Room
     *
     */
    async roomRawPayloadParser(payload) { return payload; }
    async roomRawPayload(id) {
        log.verbose('PuppetWhatsApp', 'roomRawPayload(%s)', id);
        return {};
    }
    async roomList() {
        log.verbose('PuppetWhatsApp', 'roomList()');
        return [];
    }
    async roomDel(roomId, contactId) {
        log.verbose('PuppetWhatsApp', 'roomDel(%s, %s)', roomId, contactId);
    }
    async roomAvatar(roomId) {
        log.verbose('PuppetWhatsApp', 'roomAvatar(%s)', roomId);
        const payload = await this.roomPayload(roomId);
        if (payload.avatar) {
            return FileBox.fromUrl(payload.avatar);
        }
        log.warn('PuppetWhatsApp', 'roomAvatar() avatar not found, use the chatie default.');
        return qrCodeForChatie();
    }
    async roomAdd(roomId, contactId) {
        log.verbose('PuppetWhatsApp', 'roomAdd(%s, %s)', roomId, contactId);
    }
    async roomTopic(roomId, topic) {
        log.verbose('PuppetWhatsApp', 'roomTopic(%s, %s)', roomId, topic);
        if (typeof topic === 'undefined') {
            return 'mock room topic';
        }
        await this.dirtyPayload(PayloadType.Room, roomId);
    }
    async roomCreate(contactIdList, topic) {
        log.verbose('PuppetWhatsApp', 'roomCreate(%s, %s)', contactIdList, topic);
        return 'mock_room_id';
    }
    async roomQuit(roomId) {
        log.verbose('PuppetWhatsApp', 'roomQuit(%s)', roomId);
    }
    async roomQRCode(roomId) {
        log.verbose('PuppetWhatsApp', 'roomQRCode(%s)', roomId);
        return roomId + ' mock qrcode';
    }
    async roomMemberList(roomId) {
        log.verbose('PuppetWhatsApp', 'roomMemberList(%s)', roomId);
        return [];
    }
    async roomMemberRawPayload(roomId, contactId) {
        log.verbose('PuppetWhatsApp', 'roomMemberRawPayload(%s, %s)', roomId, contactId);
        return {
            avatar: 'mock-avatar-data',
            id: 'xx',
            name: 'mock-name',
            roomAlias: 'yy',
        };
    }
    async roomMemberRawPayloadParser(rawPayload) {
        log.verbose('PuppetWhatsApp', 'roomMemberRawPayloadParser(%s)', rawPayload);
        return rawPayload;
    }
    async roomAnnounce(roomId, text) {
        if (text) {
            return;
        }
        return 'mock announcement for ' + roomId;
    }
    /**
     *
     * Room Invitation
     *
     */
    async roomInvitationAccept(roomInvitationId) {
        log.verbose('PuppetWhatsApp', 'roomInvitationAccept(%s)', roomInvitationId);
    }
    async roomInvitationRawPayload(roomInvitationId) {
        log.verbose('PuppetWhatsApp', 'roomInvitationRawPayload(%s)', roomInvitationId);
    }
    async roomInvitationRawPayloadParser(rawPayload) {
        log.verbose('PuppetWhatsApp', 'roomInvitationRawPayloadParser(%s)', JSON.stringify(rawPayload));
        return rawPayload;
    }
    /**
     *
     * Friendship
     *
     */
    async friendshipRawPayload(id) {
        return { id };
    }
    async friendshipRawPayloadParser(rawPayload) {
        return rawPayload;
    }
    async friendshipSearchPhone(phone) {
        log.verbose('PuppetWhatsApp', 'friendshipSearchPhone(%s)', phone);
        return null;
    }
    async friendshipSearchWeixin(weixin) {
        log.verbose('PuppetWhatsApp', 'friendshipSearchWeixin(%s)', weixin);
        return null;
    }
    async friendshipAdd(contactId, hello) {
        log.verbose('PuppetWhatsApp', 'friendshipAdd(%s, %s)', contactId, hello);
    }
    async friendshipAccept(friendshipId) {
        log.verbose('PuppetWhatsApp', 'friendshipAccept(%s)', friendshipId);
    }
    /**
     *
     * Tag
     *
     */
    async tagContactAdd(tagId, contactId) {
        log.verbose('PuppetWhatsApp', 'tagContactAdd(%s)', tagId, contactId);
    }
    async tagContactRemove(tagId, contactId) {
        log.verbose('PuppetWhatsApp', 'tagContactRemove(%s)', tagId, contactId);
    }
    async tagContactDelete(tagId) {
        log.verbose('PuppetWhatsApp', 'tagContactDelete(%s)', tagId);
    }
    async tagContactList(contactId) {
        log.verbose('PuppetWhatsApp', 'tagContactList(%s)', contactId);
        return [];
    }
}
PuppetWhatsapp.VERSION = VERSION;
export { PuppetWhatsapp };
export default PuppetWhatsapp;
//# sourceMappingURL=puppet-whatsapp.js.map