/**
 *
 * File Box
 * https://github.com/huan/file-box
 *
 * 2018 Huan LI <zixia@zixia.net>
 *
 */
import fs from 'fs';
import nodePath from 'path';
import nodeUrl from 'url';
import mime from 'mime';
import { PassThrough, } from 'stream';
import { VERSION, } from './config.js';
import { FileBoxType, } from './file-box.type.js';
import { dataUrlToBase64, httpHeaderToFileName, httpHeadHeader, httpStream, streamToBuffer, } from './misc.js';
import { bufferToQrValue, qrValueToStream, } from './qrcode.js';
import { chunkerTransformStream } from './pure-functions/chunker-transform-stream.js';
const EMPTY_META_DATA = Object.freeze({});
export class FileBox {
    constructor(options) {
        // Only keep `basename` in this.name
        this.name = nodePath.basename(options.name);
        this.boxType = options.type;
        this.mimeType = mime.getType(this.name) || undefined;
        switch (options.type) {
            case FileBoxType.Buffer:
                if (!options.buffer) {
                    throw new Error('no buffer');
                }
                this.buffer = options.buffer;
                break;
            case FileBoxType.File:
                if (!options.path) {
                    throw new Error('no path');
                }
                this.localPath = options.path;
                break;
            case FileBoxType.Url:
                if (!options.url) {
                    throw new Error('no url');
                }
                this.remoteUrl = options.url;
                if (options.headers) {
                    this.headers = options.headers;
                }
                break;
            case FileBoxType.Stream:
                if (!options.stream) {
                    throw new Error('no stream');
                }
                this.stream = options.stream;
                break;
            case FileBoxType.QRCode:
                if (!options.qrCode) {
                    throw new Error('no QR Code');
                }
                this.qrCode = options.qrCode;
                break;
            case FileBoxType.Base64:
                if (!options.base64) {
                    throw new Error('no Base64 data');
                }
                this.base64 = options.base64;
                break;
            default:
                throw new Error(`unknown options(type): ${JSON.stringify(options)}`);
        }
    }
    /**
     *
     * Static Properties
     *
     */
    /**
     * Alias for `FileBox.fromUrl()`
     *
     * @alias fromUrl()
     */
    static fromUrl(url, name, headers) {
        if (!name) {
            const parsedUrl = new nodeUrl.URL(url);
            name = parsedUrl.pathname;
        }
        const options = {
            headers,
            name,
            type: FileBoxType.Url,
            url,
        };
        return new this(options);
    }
    /**
     * Alias for `FileBox.fromFile()`
     *
     * @alias fromFile
     */
    static fromFile(path, name) {
        if (!name) {
            name = nodePath.parse(path).base;
        }
        const options = {
            name,
            path,
            type: FileBoxType.File,
        };
        return new this(options);
    }
    static fromStream(stream, name) {
        const options = {
            name,
            stream,
            type: FileBoxType.Stream,
        };
        return new this(options);
    }
    static fromBuffer(buffer, name) {
        const options = {
            buffer,
            name,
            type: FileBoxType.Buffer,
        };
        return new this(options);
    }
    /**
     * @param base64
     * @param name the file name of the base64 data
     */
    static fromBase64(base64, name) {
        const options = {
            base64,
            name,
            type: FileBoxType.Base64,
        };
        return new this(options);
    }
    /**
     * dataURL: `data:image/png;base64,${base64Text}`,
     */
    static fromDataURL(dataUrl, name) {
        return this.fromBase64(dataUrlToBase64(dataUrl), name);
    }
    /**
     *
     * @param qrCode the value of the QR Code. For example: `https://github.com`
     */
    static fromQRCode(qrCode) {
        const options = {
            name: 'qrcode.png',
            qrCode,
            type: FileBoxType.QRCode,
        };
        return new this(options);
    }
    /**
     *
     * @static
     * @param {(FileBoxJsonObject | string)} obj
     * @returns {FileBox}
     */
    static fromJSON(obj) {
        if (typeof obj === 'string') {
            obj = JSON.parse(obj);
        }
        let fileBox;
        switch (obj.boxType) {
            case FileBoxType.Base64:
                fileBox = FileBox.fromBase64(obj.base64, obj.name);
                break;
            case FileBoxType.Url:
                fileBox = FileBox.fromUrl(obj.remoteUrl, obj.name);
                break;
            case FileBoxType.QRCode:
                fileBox = FileBox.fromQRCode(obj.qrCode);
                break;
            default:
                throw new Error(`unknown filebox json object{type}: ${JSON.stringify(obj)}`);
        }
        fileBox.metadata = obj.metadata;
        return fileBox;
    }
    static version() {
        return VERSION;
    }
    get metadata() {
        if (this._metadata) {
            return this._metadata;
        }
        return EMPTY_META_DATA;
    }
    set metadata(data) {
        if (this._metadata) {
            throw new Error('metadata can not be modified after set');
        }
        this._metadata = { ...data };
        Object.freeze(this._metadata);
    }
    version() {
        return VERSION;
    }
    type() {
        return this.boxType;
    }
    async ready() {
        if (this.boxType === FileBoxType.Url) {
            await this.syncRemoteName();
        }
    }
    /**
     * @todo use http.get/gets instead of Request
     */
    async syncRemoteName() {
        /**
         * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition
         *  > Content-Disposition: attachment; filename="cool.html"
         */
        if (this.boxType !== FileBoxType.Url) {
            throw new Error('type is not Remote');
        }
        if (!this.remoteUrl) {
            throw new Error('no url');
        }
        const headers = await httpHeadHeader(this.remoteUrl);
        const filename = httpHeaderToFileName(headers);
        if (filename) {
            this.name = filename;
        }
        if (!this.name) {
            throw new Error('no name');
        }
        this.mimeType = headers['content-type'] || mime.getType(this.name) || undefined;
    }
    /**
     *
     * toXXX methods
     *
     */
    toString() {
        return [
            'FileBox#',
            FileBoxType[this.boxType],
            '<',
            this.name,
            '>',
        ].join('');
    }
    toJSON() {
        const objCommon = {
            metadata: this.metadata,
            name: this.name,
        };
        let obj;
        switch (this.boxType) {
            case FileBoxType.Url: {
                if (!this.remoteUrl) {
                    throw new Error('no url');
                }
                const objUrl = {
                    boxType: FileBoxType.Url,
                    headers: this.headers,
                    remoteUrl: this.remoteUrl,
                };
                obj = {
                    ...objCommon,
                    ...objUrl,
                };
                break;
            }
            case FileBoxType.QRCode: {
                if (!this.qrCode) {
                    throw new Error('no qr code');
                }
                const objQRCode = {
                    boxType: FileBoxType.QRCode,
                    qrCode: this.qrCode,
                };
                obj = {
                    ...objCommon,
                    ...objQRCode,
                };
                break;
            }
            case FileBoxType.Base64: {
                if (!this.base64) {
                    throw new Error('no base64 data');
                }
                const objBase64 = {
                    base64: this.base64,
                    boxType: FileBoxType.Base64,
                };
                obj = {
                    ...objCommon,
                    ...objBase64,
                };
                break;
            }
            default:
                throw new Error('FileBox.toJSON() can only work on limited FileBoxType(s). See: <https://github.com/huan/file-box/issues/25>');
        }
        return obj;
    }
    async toStream() {
        let stream;
        switch (this.boxType) {
            case FileBoxType.Buffer:
                stream = this.transformBufferToStream();
                break;
            case FileBoxType.File:
                stream = this.transformFileToStream();
                break;
            case FileBoxType.Url:
                stream = await this.transformUrlToStream();
                break;
            case FileBoxType.Stream:
                if (!this.stream) {
                    throw new Error('no stream');
                }
                /**
                  * Huan(202109): the stream.destroyed will not be `true`
                  *   when we have read all the data
                  *   after we change some code.
                  * The reason is unknown... so we change to check `readable`
                  */
                if (!this.stream.readable) {
                    throw new Error('The stream is not readable. Maybe has already been consumed, and now it was drained. See: https://github.com/huan/file-box/issues/50');
                }
                stream = this.stream;
                break;
            case FileBoxType.QRCode:
                if (!this.qrCode) {
                    throw new Error('no QR Code');
                }
                stream = await this.transformQRCodeToStream();
                break;
            case FileBoxType.Base64:
                if (!this.base64) {
                    throw new Error('no base64 data');
                }
                stream = this.transformBase64ToStream();
                break;
            default:
                throw new Error('not supported FileBoxType: ' + FileBoxType[this.boxType]);
        }
        return stream;
    }
    /**
     * https://stackoverflow.com/a/16044400/1123955
     */
    transformBufferToStream(buffer) {
        const bufferStream = new PassThrough();
        bufferStream.end(buffer || this.buffer);
        /**
         * Use small `chunks` with `toStream()` #44
         * https://github.com/huan/file-box/issues/44
         */
        return bufferStream.pipe(chunkerTransformStream());
    }
    transformBase64ToStream() {
        if (!this.base64) {
            throw new Error('no base64 data');
        }
        const buffer = Buffer.from(this.base64, 'base64');
        return this.transformBufferToStream(buffer);
    }
    transformFileToStream() {
        if (!this.localPath) {
            throw new Error('no url(path)');
        }
        return fs.createReadStream(this.localPath);
    }
    async transformUrlToStream() {
        return new Promise((resolve, reject) => {
            if (this.remoteUrl) {
                httpStream(this.remoteUrl, this.headers)
                    .then(resolve)
                    .catch(reject);
            }
            else {
                reject(new Error('no url'));
            }
        });
    }
    async transformQRCodeToStream() {
        if (!this.qrCode) {
            throw new Error('no QR Code Value found');
        }
        const stream = qrValueToStream(this.qrCode);
        return stream;
    }
    /**
     * save file
     *
     * @param filePath save file
     */
    async toFile(filePath, overwrite = false) {
        if (this.boxType === FileBoxType.Url) {
            if (!this.mimeType || !this.name) {
                await this.syncRemoteName();
            }
        }
        const fullFilePath = nodePath.resolve(filePath || this.name);
        const exist = fs.existsSync(fullFilePath);
        if (exist && !overwrite) {
            throw new Error(`FileBox.toFile(${fullFilePath}): file exist. use FileBox.toFile(${fullFilePath}, true) to force overwrite.`);
        }
        const writeStream = fs.createWriteStream(fullFilePath);
        /**
          * Huan(202109): make sure the file can be opened for writting
          *   before we pipe the stream to it
          */
        await new Promise((resolve, reject) => writeStream
            .once('open', resolve)
            .once('error', reject));
        /**
          * Start pipe
          */
        await new Promise((resolve, reject) => {
            writeStream
                .once('close', resolve)
                .once('error', reject);
            this.pipe(writeStream);
        });
    }
    async toBase64() {
        if (this.boxType === FileBoxType.Base64) {
            if (!this.base64) {
                throw new Error('no base64 data');
            }
            return this.base64;
        }
        const buffer = await this.toBuffer();
        return buffer.toString('base64');
    }
    /**
     * dataUrl: `data:image/png;base64,${base64Text}',
     */
    async toDataURL() {
        const base64Text = await this.toBase64();
        if (!this.mimeType) {
            throw new Error('no mimeType');
        }
        const dataUrl = [
            'data:',
            this.mimeType,
            ';base64,',
            base64Text,
        ].join('');
        return dataUrl;
    }
    async toBuffer() {
        if (this.boxType === FileBoxType.Buffer) {
            if (!this.buffer) {
                throw new Error('no buffer!');
            }
            return this.buffer;
        }
        const stream = new PassThrough();
        this.pipe(stream);
        const buffer = await streamToBuffer(stream);
        return buffer;
    }
    async toQRCode() {
        if (this.boxType === FileBoxType.QRCode) {
            if (!this.qrCode) {
                throw new Error('no QR Code!');
            }
            return this.qrCode;
        }
        const buf = await this.toBuffer();
        const qrValue = await bufferToQrValue(buf);
        return qrValue;
    }
    /**
     *
     * toXXX methods END
     *
     */
    pipe(destination) {
        this.toStream().then(stream => {
            stream.on('error', e => {
                console.info('error:', e);
                destination.emit('error', e);
            });
            return stream.pipe(destination);
        }).catch(e => destination.emit('error', e));
        return destination;
    }
}
export default FileBox;
//# sourceMappingURL=file-box.js.map