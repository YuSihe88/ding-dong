"use strict";
/**
 * Huan(202110): Assignment and Resolution of Uniform Resource Names
 *  https://datatracker.ietf.org/wg/urn/about/
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniformResourceNameRegistry = void 0;
/**
 * RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace
 *  ------------------------------------------------------------
 *  This specification defines a Uniform Resource Name namespace for
 *  UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally
 *  Unique IDentifier).  A UUID is 128 bits long, and can guarantee
 *  uniqueness across space and time.  UUIDs were originally used in the
 *  Apollo Network Computing System and later in the Open Software
 *  Foundation's (OSF) Distributed Computing Environment (DCE), and then
 *  in Microsoft Windows platforms.
 *
 *  The information here is meant to be a concise guide for those wishing
 *  to implement services using UUIDs as URNs.  Nothing in this document
 *  should be construed to override the DCE standards that defined UUIDs.
 */
/**
 * RFC 2141: Uniform Resource Names (URNs) Syntax
 * ----------------------------------------------
 *  Uniform Resource Names (URNs) are intended to serve as persistent,
 *  location-independent, resource identifiers. This document sets
 *  forward the canonical syntax for URNs.  A discussion of both existing
 *  legacy and new namespaces and requirements for URN presentation and
 *  transmission are presented.  Finally, there is a discussion of URN
 *  equivalence and how to determine it.
 */
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const clone_class_1 = require("clone-class");
const brolog_1 = require("brolog");
const random_uuid_js_1 = require("./random-uuid.js");
/**
 * A UUID will be only keep for a certain time.
 */
const DEFAULT_UUID_EXPIRE_MINUTES = 30;
class UniformResourceNameRegistry {
    constructor(options = {}) {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'constructor("%s")', JSON.stringify(options));
        this.uuidTimerMap = new Map();
        this.expireMilliseconds = options.expireMilliseconds ?? (DEFAULT_UUID_EXPIRE_MINUTES * 60 * 1000 * 1000);
        this.storeDir = options.storeDir || path_1.default.join(os_1.default.tmpdir(), 'uniform-resource-name-registry.' + String(process.pid));
    }
    async init() {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'init()');
        try {
            const stat = await fs_1.default.promises.stat(this.storeDir);
            if (!stat.isDirectory()) {
                throw new Error(this.storeDir + ' is Not a directory');
            }
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                await fs_1.default.promises.mkdir(this.storeDir, { recursive: true });
            }
            else {
                throw e;
            }
        }
        await this.addProcessExitListener();
    }
    /**
     * Clean up by calling this.destroy() before process exit
     */
    async addProcessExitListener() {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'addProcessExitListener()');
        const Klass = (0, clone_class_1.instanceToClass)(this, UniformResourceNameRegistry);
        /**
         * If we have already registered the listener, do nothing.
         */
        if (Klass.removeProcessExitListenerMap.has(this)) {
            return;
        }
        const destroyCallback = () => this.destroy();
        process.addListener('exit', destroyCallback);
        Klass.removeProcessExitListenerMap.set(this, () => process.removeListener('exit', destroyCallback));
    }
    uuidFile(uuid) {
        return path_1.default.join(this.storeDir, uuid);
    }
    /**
     * `resolve()` can only be used once.
     *  after resolve(), the UUID will be not exist any more
     */
    async resolve(uuid) {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'resolve(%s)', uuid);
        /**
         * Check & remove UUID from timer map
         */
        if (!this.uuidTimerMap.has(uuid)) {
            throw new Error('UniformResourceNameRegistry resolve(' + uuid + ') but not exist');
        }
        const timer = this.uuidTimerMap.get(uuid);
        this.uuidTimerMap.delete(uuid);
        if (timer) {
            clearTimeout(timer);
        }
        const file = this.uuidFile(uuid);
        const stream = fs_1.default.createReadStream(file);
        /**
         * Remove the file after read
         */
        stream.on('end', () => this.delete(uuid));
        await new Promise((resolve, reject) => {
            stream.on('ready', resolve);
            stream.on('error', reject);
        });
        return stream;
    }
    /**
     * Save the `Readable` stream and return a random UUID
     *  The UUID will be expired after MAX_KEEP_MINUTES
     */
    async register(stream) {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'register(stream)');
        const uuid = (0, random_uuid_js_1.randomUuid)();
        const fileStream = fs_1.default.createWriteStream(this.uuidFile(uuid));
        const future = new Promise((resolve, reject) => {
            stream.on('end', resolve);
            stream.on('error', reject);
            fileStream.on('error', reject);
        });
        stream.pipe(fileStream);
        await future;
        this.addTimer(uuid);
        return uuid;
    }
    /**
     * Set a timer to execute delete callback after `expireMilliseconds`
     */
    addTimer(uuid) {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'addTimer(%s)', uuid);
        const timer = setTimeout(() => this.delete(uuid), this.expireMilliseconds);
        this.uuidTimerMap.set(uuid, timer);
    }
    async delete(uuid) {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'delete(%s)', uuid);
        /**
         * 1. Clear the timer (if there's any)
         */
        const timer = this.uuidTimerMap.get(uuid);
        if (timer) {
            this.uuidTimerMap.delete(uuid);
            clearTimeout(timer);
        }
        /**
        * 2. Delete the file
        */
        const unlinkUuid = this.unlinkFactory(uuid);
        await unlinkUuid();
    }
    unlinkFactory(uuid) {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'unlinkFactory(%s)', uuid);
        const file = this.uuidFile(uuid);
        return async () => {
            try {
                await fs_1.default.promises.unlink(file);
                brolog_1.log.silly('UniformResourceNameRegistry', 'unlinkFactory() unlink(%s)', file);
            }
            catch (e) {
                brolog_1.log.warn('UniformResourceNameRegistry', 'unlinkFactory() unlink() rejection:', e.message);
            }
        };
    }
    destroy() {
        brolog_1.log.verbose('UniformResourceNameRegistry', 'destroy() %s UUIDs left', this.uuidTimerMap.size);
        const Klass = (0, clone_class_1.instanceToClass)(this, UniformResourceNameRegistry);
        /**
         * Remove process exit listener
         */
        if (Klass.removeProcessExitListenerMap.has(this)) {
            const fn = Klass.removeProcessExitListenerMap.get(this);
            Klass.removeProcessExitListenerMap.delete(this);
            fn && fn();
        }
        /**
         * Clear all the timers
         */
        const timerList = this.uuidTimerMap.values();
        for (const timer of timerList) {
            clearTimeout(timer);
        }
        /**
         * Clean up all the files
         */
        brolog_1.log.verbose('UniformResourceNameRegistry', 'destroy() fs.rmSync(%s) ...', this.storeDir);
        try {
            /**
             * Huan(202110):
             *  Check for the `this.uuidDir` exist or not
             *    when we are running unit tests, we might instanciate multiple UniformResourceNameRegistry
             *    which will cause the `this.destroy()` to be registered multiple times
             */
            fs_1.default.statSync(this.storeDir);
            fs_1.default.rmSync(this.storeDir, { recursive: true });
            brolog_1.log.verbose('UniformResourceNameRegistry', 'destroy() fs.rmSync(%s) done', this.storeDir);
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                brolog_1.log.verbose('UniformResourceNameRegistry', 'destroy() %s not exist', this.storeDir);
                return;
            }
            brolog_1.log.warn('UniformResourceNameRegistry', 'destroy() fs.rmSync(%s) exception: %s', e.message);
        }
    }
}
exports.UniformResourceNameRegistry = UniformResourceNameRegistry;
UniformResourceNameRegistry.removeProcessExitListenerMap = new WeakMap();
//# sourceMappingURL=uniform-resource-name-registry.js.map