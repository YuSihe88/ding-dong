import { log, } from 'wechaty-puppet';
import { RoomEventEmitter } from '../events/room-events.js';
const POOL = Symbol('pool');
class RoomMock extends RoomEventEmitter {
    constructor(payload) {
        super();
        this.payload = payload;
        log.silly('MockRoom', 'constructor(%s)', JSON.stringify(payload));
        this.mocker.roomPayload(payload.id, payload);
    }
    static get mocker() { throw new Error('This class can not be used directory. See: https://github.com/wechaty/wechaty/issues/2027'); }
    get mocker() { throw new Error('This class can not be used directory. See: https://github.com/wechaty/wechaty/issues/2027'); }
    static get pool() {
        if (!this[POOL]) {
            log.verbose('MockRoom', 'get pool() init pool');
            this[POOL] = new Map();
        }
        if (this === RoomMock) {
            throw new Error('The global MockRoom class can not be used directly!'
                + 'See: https://github.com/wechaty/wechaty/issues/1217');
        }
        return this[POOL];
    }
    /**
     * @ignore
     * About the Generic: https://stackoverflow.com/q/43003970/1123955
     * @static
     * @param {string} id
     * @returns {Room}
     */
    static load(id) {
        const existingRoom = this.pool.get(id);
        if (!existingRoom) {
            throw new Error(`MockRoom.load(): ${id} not exist.`);
        }
        return existingRoom;
    }
    static create(payload) {
        log.verbose('MockRoom', 'static create(%s)', JSON.stringify(payload));
        if (this.pool.get(payload.id)) {
            throw new Error('MockRoom id ' + payload.id + ' has already created before. Use `load(' + payload.id + ')` to get it back.');
        }
        // when we call `load()`, `this` should already be extend-ed a child class.
        // so we force `this as any` at here to make the call.
        const newRoom = new this(payload);
        this.pool.set(newRoom.id, newRoom);
        return newRoom;
    }
    get id() { return this.payload.id; }
    topic(text) {
        log.verbose('MockRoom', 'topic(%s)', text);
        const that = this;
        return { by };
        function by(contact) {
            log.verbose('MockRoom', 'topic(%s).by(%s)', text, contact?.id || '');
            if (!contact) {
                contact = that.mocker.randomContact();
                if (!contact) {
                    throw new Error('no contact found by mocker');
                }
            }
            const payload = {
                changerId: contact.id,
                newTopic: text,
                oldTopic: that.payload.topic,
                roomId: that.payload.id,
                timestamp: Date.now(),
            };
            that.mocker.puppet.emit('room-topic', payload);
            that.payload.topic = text;
        }
    }
    add(...inviteeList) {
        log.verbose('MockRoom', 'add(%s)', inviteeList.map(i => i.id).join(','));
        const that = this;
        return { by };
        function by(inviter) {
            log.verbose('MockRoom', 'add(%s).by(%s)', inviteeList.map(i => i.id).join(','), inviter?.id || '');
            if (!inviter) {
                inviter = that.mocker.randomContact();
                if (!inviter) {
                    throw new Error('no contact found by mocker');
                }
            }
            that.payload.memberIdList.push(...inviteeList.map(i => i.id));
            const payload = {
                inviteeIdList: inviteeList.map(i => i.id),
                inviterId: inviter.id,
                roomId: that.id,
                timestamp: Date.now(),
            };
            that.mocker.puppet.emit('room-join', payload);
        }
    }
    remove(...removeeList) {
        log.verbose('MockRoom', 'remove(%s)', removeeList.map(i => i.id).join(','));
        const that = this;
        return { by };
        function by(remover) {
            log.verbose('MockRoom', 'remove(%s).by(%s)', removeeList.map(i => i.id).join(','), remover?.id || '');
            if (!remover) {
                remover = that.mocker.randomContact();
                if (!remover) {
                    throw new Error('no contact found by mocker');
                }
            }
            for (const removee of removeeList) {
                const index = that.payload.memberIdList.indexOf(removee.id);
                if (index > -1) {
                    that.payload.memberIdList.splice(index, 1);
                }
            }
            const payload = {
                removeeIdList: removeeList.map(r => r.id),
                removerId: remover.id,
                roomId: that.id,
                timestamp: Date.now(),
            };
            that.mocker.puppet.emit('room-leave', payload);
        }
    }
}
function mockerifyRoomMock(mocker) {
    class MockerifiedRoomMock extends RoomMock {
        static get mocker() { return mocker; }
        get mocker() { return mocker; }
    }
    return MockerifiedRoomMock;
}
export { RoomMock, mockerifyRoomMock, };
//# sourceMappingURL=room-mock.js.map