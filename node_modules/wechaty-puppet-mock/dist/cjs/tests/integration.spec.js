#!/usr/bin/env node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const wechaty_1 = require("wechaty");
const mod_js_1 = require("../src/mod.js");
async function* wechatyFixture() {
    const mocker = new mod_js_1.mock.Mocker();
    const puppet = new mod_js_1.PuppetMock({ mocker });
    const wechaty = new wechaty_1.Wechaty({ puppet });
    try {
        await wechaty.start();
        yield {
            mocker,
            wechaty,
        };
    }
    finally {
        await wechaty.stop();
    }
}
(0, tstest_1.test)('integration testing', async (t) => {
    const mocker = new mod_js_1.mock.Mocker();
    const puppet = new mod_js_1.PuppetMock({ mocker });
    const wechaty = new wechaty_1.Wechaty({ puppet });
    t.ok(wechaty, 'should instantiate wechaty with puppet mocker');
});
(0, tstest_1.test)('Contact.find() mocker.createContacts()', async (t) => {
    for await (const { mocker, wechaty, } of wechatyFixture()) {
        const CONTACTS_NUM = 5;
        const [user, mike] = mocker.createContacts(CONTACTS_NUM);
        mocker.login(user);
        const contactList = await wechaty.Contact.findAll();
        t.equal(contactList.length, CONTACTS_NUM, 'should find all contacts create by mocker');
        const contact = await wechaty.Contact.find({ name: mike.payload.name });
        t.ok(contact, 'should find a contact by name of mike');
        t.equal(contact.id, mike.id, 'should find the contact the same id as mike');
    }
});
(0, tstest_1.test)('Room.find() mocker.createRooms()', async (t) => {
    for await (const { mocker, wechaty, } of wechatyFixture()) {
        const user = mocker.createContact();
        mocker.login(user);
        const ROOMS_NUM = 5;
        const [starbucks] = mocker.createRooms(ROOMS_NUM);
        const roomList = await wechaty.Room.findAll();
        t.equal(roomList.length, ROOMS_NUM, 'should find all rooms create by mocker');
        const room = await wechaty.Room.find({ topic: starbucks.payload.topic });
        t.ok(room, 'should find a room by topic of starbucks');
        t.equal(room.id, starbucks.id, 'should find the room the same id as starbucks');
    }
});
(0, tstest_1.test)('Contact.load() mocker.createContact()', async (t) => {
    for await (const { mocker, wechaty, } of wechatyFixture()) {
        const user = mocker.createContact();
        mocker.login(user);
        const FILE_HELPER_ID = 'filehelper';
        const filehelper = mocker.createContact({
            id: FILE_HELPER_ID,
        });
        const contact = await wechaty.Contact.load(FILE_HELPER_ID);
        t.ok(contact, 'should load contact by id');
        t.equal(contact.id, filehelper.id, 'should load contact with id the same as filehelper');
        await contact.ready();
        t.same(contact.payload, filehelper.payload, 'should match the payload between wechaty contact & mock contact');
    }
});
(0, tstest_1.test)('Room.load() mocker.createRoom()', async (t) => {
    for await (const { mocker, wechaty, } of wechatyFixture()) {
        const user = mocker.createContact();
        mocker.login(user);
        const starbucks = mocker.createRoom();
        const room = await wechaty.Room.load(starbucks.id);
        t.ok(room, 'should load room by id');
        t.equal(room.id, starbucks.id, 'should load room with id the same as starbucks');
        await room.ready();
        t.same(room.payload, starbucks.payload, 'should match the payload between wechaty room & mock room');
    }
});
(0, tstest_1.test)('Wechaty bot can receive message sent from mocker', async (t) => {
    for await (const { mocker, wechaty, } of wechatyFixture()) {
        await wechaty.start();
        const bot = mocker.createContact({ name: 'Bot' });
        const player = mocker.createContact({ name: 'Player' });
        mocker.login(bot);
        const wechatyUserSelf = wechaty.wechaty.userSelf();
        const directMessage = await new Promise(resolve => {
            wechatyUserSelf.once('message', resolve);
            player.say().to(bot);
        });
        t.ok(directMessage, 'should resolve a message');
        await new Promise(setImmediate);
    }
});
//# sourceMappingURL=integration.spec.js.map