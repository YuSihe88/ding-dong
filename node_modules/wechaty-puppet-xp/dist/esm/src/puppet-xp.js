var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _PuppetXp_instances, _PuppetXp_sidecar, _PuppetXp_tryStart, _PuppetXp_tryStop;
/**
 *   Wechaty - https://github.com/chatie/wechaty
 *
 *   @copyright 2016-2018 Huan LI <zixia@zixia.net>
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
import cuid from 'cuid';
import path from 'path';
import fs from 'fs';
import xml2js from 'xml2js';
import { FileBox, ImageType, Puppet, log, MessageType, ContactGender, ContactType, throwUnsupportedError, FileBoxType, } from 'wechaty-puppet';
import { attach, detach, } from 'sidecar';
import { CHATIE_OFFICIAL_ACCOUNT_QRCODE, qrCodeForChatie, VERSION, } from './config.js';
import { WeChatSidecar } from './wechat-sidecar.js';
class PuppetXp extends Puppet {
    constructor(options = {}) {
        super(options);
        this.options = options;
        _PuppetXp_instances.add(this);
        _PuppetXp_sidecar.set(this, void 0);
        log.verbose('PuppetXp', 'constructor(%s)', JSON.stringify(options));
        // FIXME: use LRU cache for message store so that we can reduce memory usage
        this.messageStore = {};
        this.roomStore = {};
        this.contactStore = {};
        this.selfInfo = {};
    }
    get sidecar() {
        return __classPrivateFieldGet(this, _PuppetXp_sidecar, "f");
    }
    version() {
        return VERSION;
    }
    async start() {
        log.verbose('PuppetXp', 'start()');
        if (this.state.on()) {
            log.warn('PuppetXp', 'start() is called on a ON puppet. await ready(on) and return.');
            await this.state.ready('on');
            return;
        }
        this.state.on('pending');
        try {
            await __classPrivateFieldGet(this, _PuppetXp_instances, "m", _PuppetXp_tryStart).call(this);
            await super.start();
            this.state.on(true);
        }
        catch (e) {
            this.state.off(true);
        }
    }
    async stop() {
        log.verbose('PuppetXp', 'stop()');
        if (this.state.off()) {
            log.warn('PuppetXp', 'stop() is called on a OFF puppet. await ready(off) and return.');
            await this.state.ready('off');
            return;
        }
        this.state.off('pending');
        try {
            await super.stop();
            await __classPrivateFieldGet(this, _PuppetXp_instances, "m", _PuppetXp_tryStop).call(this);
        }
        catch (e) {
            log.error('PuppetXp', 'stop() rejection: %s', e.message);
        }
        finally {
            this.state.off(true);
        }
    }
    login(contactId) {
        log.verbose('PuppetXp', 'login()');
        return super.login(contactId);
    }
    async logout() {
        log.verbose('PuppetXp', 'logout()');
        if (!this.id) {
            throw new Error('logout before login?');
        }
        this.emit('logout', { contactId: this.id, data: 'test' }); // before we will throw above by logonoff() when this.user===undefined
        this.id = undefined;
        // TODO: do the logout job
    }
    ding(data) {
        log.silly('PuppetXp', 'ding(%s)', data || '');
        setTimeout(() => this.emit('dong', { data: data || '' }), 1000);
    }
    unref() {
        log.verbose('PuppetXp', 'unref()');
        super.unref();
    }
    /**
    *
    * ContactSelf
    *
    *
    */
    async contactSelfQRCode() {
        log.verbose('PuppetXp', 'contactSelfQRCode()');
        return CHATIE_OFFICIAL_ACCOUNT_QRCODE;
    }
    async contactSelfName(name) {
        log.verbose('PuppetXp', 'contactSelfName(%s)', name);
        if (!name) {
            return this.selfInfo.name;
        }
    }
    async contactSelfSignature(signature) {
        log.verbose('PuppetXp', 'contactSelfSignature(%s)', signature);
    }
    async contactAlias(contactId, alias) {
        log.verbose('PuppetXp', 'contactAlias(%s, %s)', contactId, alias);
        const contact = await this.contactRawPayload(contactId);
        // if (typeof alias === 'undefined') {
        //   throw new Error('to be implement')
        // }
        return contact.alias;
    }
    async contactPhone(contactId, phoneList) {
        log.verbose('PuppetXp', 'contactPhone(%s, %s)', contactId, phoneList);
        if (typeof phoneList === 'undefined') {
            return [];
        }
    }
    async contactCorporationRemark(contactId, corporationRemark) {
        log.verbose('PuppetXp', 'contactCorporationRemark(%s, %s)', contactId, corporationRemark);
    }
    async contactDescription(contactId, description) {
        log.verbose('PuppetXp', 'contactDescription(%s, %s)', contactId, description);
    }
    async contactList() {
        log.verbose('PuppetXp', 'contactList()');
        const idList = Object.keys(this.contactStore);
        return idList;
    }
    async contactAvatar(contactId, file) {
        log.verbose('PuppetXp', 'contactAvatar(%s)', contactId);
        /**
        * 1. set
        */
        if (file) {
            return;
        }
        /**
        * 2. get
        */
        const WECHATY_ICON_PNG = path.resolve('../../docs/images/wechaty-icon.png');
        return FileBox.fromFile(WECHATY_ICON_PNG);
    }
    async contactRawPayloadParser(payload) {
        // log.verbose('PuppetXp', 'contactRawPayloadParser(%s)', JSON.stringify(payload))
        return payload;
    }
    async contactRawPayload(id) {
        log.verbose('PuppetXp----------------------', 'contactRawPayload(%s)', id);
        return this.contactStore[id] || {};
    }
    /**
    *
    * Conversation
    *
    */
    async conversationReadMark(conversationId, hasRead) {
        log.verbose('PuppetService', 'conversationRead(%s, %s)', conversationId, hasRead);
    }
    /**
    *
    * Message
    *
    */
    async messageContact(messageId) {
        log.verbose('PuppetXp', 'messageContact(%s)', messageId);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof ContactMock) {
        //   return attachment.id
        // }
        return this.messageStore[messageId]?.fromId || '';
    }
    async messageImage(messageId, imageType) {
        log.verbose('PuppetXp', 'messageImage(%s, %s[%s])', messageId, imageType, ImageType[imageType]);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof FileBox) {
        //   return attachment
        // }
        return FileBox.fromQRCode('fake-qrcode');
    }
    async messageRecall(messageId) {
        log.verbose('PuppetXp', 'messageRecall(%s)', messageId);
        return false;
    }
    async messageFile(id) {
        // const attachment = this.mocker.MockMessage.loadAttachment(id)
        // if (attachment instanceof FileBox) {
        //   return attachment
        // }
        return FileBox.fromBase64('cRH9qeL3XyVnaXJkppBuH20tf5JlcG9uFX1lL2IvdHRRRS9kMMQxOPLKNYIzQQ==', 'mock-file' + id + '.txt');
    }
    async messageUrl(messageId) {
        log.verbose('PuppetXp', 'messageUrl(%s)', messageId);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof UrlLink) {
        //   return attachment.payload
        // }
        return {
            title: 'mock title for ' + messageId,
            url: 'https://mock.url',
        };
    }
    async messageMiniProgram(messageId) {
        log.verbose('PuppetXp', 'messageMiniProgram(%s)', messageId);
        // const attachment = this.mocker.MockMessage.loadAttachment(messageId)
        // if (attachment instanceof MiniProgram) {
        //   return attachment.payload
        // }
        return {
            title: 'mock title for ' + messageId,
        };
    }
    async messageLocation(messageId) {
        log.verbose('PuppetXp', 'messageLocation(%s)', messageId);
        return {
            accuracy: 15,
            address: '北京市北京市海淀区45 Chengfu Rd',
            latitude: 39.995120999999997,
            longitude: 116.334154,
            name: '东升乡政府',
        };
    }
    async messageRawPayloadParser(payload) {
        // console.info(payload)
        return payload;
    }
    async messageRawPayload(id) {
        log.verbose('PuppetXp', 'messageRawPayload(%s)', id);
        const payload = this.messageStore[id];
        if (!payload) {
            throw new Error('no payload');
        }
        return payload;
    }
    async messageSendText(conversationId, text, mentionIdList) {
        if (conversationId.split('@').length === 2 && mentionIdList && mentionIdList[0]) {
            await this.sidecar.sendAtMsg(conversationId, text, mentionIdList[0]);
        }
        else {
            await this.sidecar.sendMsg(conversationId, text);
        }
    }
    async messageSendFile(conversationId, file) {
        // throwUnsupportedError(conversationId, file)
        const filePath = path.resolve(file.name);
        await file.toFile(filePath, true);
        if (file.type() === FileBoxType.Url) {
            try {
                await this.sidecar.sendPicMsg(conversationId, filePath);
                fs.unlinkSync(filePath);
            }
            catch {
                fs.unlinkSync(filePath);
            }
        }
        else {
            throwUnsupportedError(conversationId, file);
        }
    }
    async messageSendContact(conversationId, contactId) {
        log.verbose('PuppetXp', 'messageSendUrl(%s, %s)', conversationId, contactId);
        // const contact = this.mocker.MockContact.load(contactId)
        // return this.messageSend(conversationId, contact)
    }
    async messageSendUrl(conversationId, urlLinkPayload) {
        log.verbose('PuppetXp', 'messageSendUrl(%s, %s)', conversationId, JSON.stringify(urlLinkPayload));
        // const url = new UrlLink(urlLinkPayload)
        // return this.messageSend(conversationId, url)
    }
    async messageSendMiniProgram(conversationId, miniProgramPayload) {
        log.verbose('PuppetXp', 'messageSendMiniProgram(%s, %s)', conversationId, JSON.stringify(miniProgramPayload));
        // const miniProgram = new MiniProgram(miniProgramPayload)
        // return this.messageSend(conversationId, miniProgram)
    }
    async messageSendLocation(conversationId, locationPayload) {
        log.verbose('PuppetXp', 'messageSendLocation(%s, %s)', conversationId, JSON.stringify(locationPayload));
    }
    async messageForward(conversationId, messageId) {
        log.verbose('PuppetXp', 'messageForward(%s, %s)', conversationId, messageId);
        const curMessage = this.messageStore[messageId];
        if (curMessage?.type === MessageType.Text) {
            await this.messageSendText(conversationId, curMessage.text || '');
        }
        else {
            throwUnsupportedError(conversationId, messageId);
        }
    }
    /**
    *
    * Room
    *
    */
    async roomRawPayloadParser(payload) { return payload; }
    async roomRawPayload(id) {
        // log.verbose('PuppetXp', 'roomRawPayload(%s)', id)
        return this.roomStore[id] || {};
    }
    async roomList() {
        log.verbose('PuppetXp', 'roomList()');
        const idList = Object.keys(this.roomStore);
        return idList;
    }
    async roomDel(roomId, contactId) {
        log.verbose('PuppetXp', 'roomDel(%s, %s)', roomId, contactId);
    }
    async roomAvatar(roomId) {
        log.verbose('PuppetXp', 'roomAvatar(%s)', roomId);
        const payload = await this.roomPayload(roomId);
        if (payload.avatar) {
            return FileBox.fromUrl(payload.avatar);
        }
        log.warn('PuppetXp', 'roomAvatar() avatar not found, use the chatie default.');
        return qrCodeForChatie();
    }
    async roomAdd(roomId, contactId) {
        log.verbose('PuppetXp', 'roomAdd(%s, %s)', roomId, contactId);
    }
    async roomTopic(roomId, topic) {
        log.verbose('PuppetXp', 'roomTopic(%s, %s)', roomId, topic);
        const payload = await this.roomPayload(roomId);
        if (!topic) {
            return payload.topic;
        }
        else {
            return payload.topic;
        }
    }
    async roomCreate(contactIdList, topic) {
        log.verbose('PuppetXp', 'roomCreate(%s, %s)', contactIdList, topic);
        return 'mock_room_id';
    }
    async roomQuit(roomId) {
        log.verbose('PuppetXp', 'roomQuit(%s)', roomId);
    }
    async roomQRCode(roomId) {
        log.verbose('PuppetXp', 'roomQRCode(%s)', roomId);
        return roomId + ' mock qrcode';
    }
    async roomMemberList(roomId) {
        log.verbose('PuppetXp', 'roomMemberList(%s)', roomId);
        return (await this.roomRawPayload(roomId)).memberIdList;
    }
    async roomMemberRawPayload(roomId, contactId) {
        log.verbose('PuppetXp', 'roomMemberRawPayload(%s, %s)', roomId, contactId);
        const contact = this.contactStore[contactId];
        const MemberRawPayload = {
            avatar: '',
            id: contactId,
            inviterId: contactId,
            name: contact?.name || '',
            roomAlias: contact?.name || '',
        };
        // console.info(MemberRawPayload)
        return MemberRawPayload;
    }
    async roomMemberRawPayloadParser(rawPayload) {
        log.verbose('PuppetXp---------------------', 'roomMemberRawPayloadParser(%s)', rawPayload);
        return rawPayload;
    }
    async roomAnnounce(roomId, text) {
        if (text) {
            return;
        }
        return 'mock announcement for ' + roomId;
    }
    /**
    *
    * Room Invitation
    *
    */
    async roomInvitationAccept(roomInvitationId) {
        log.verbose('PuppetXp', 'roomInvitationAccept(%s)', roomInvitationId);
    }
    async roomInvitationRawPayload(roomInvitationId) {
        log.verbose('PuppetXp', 'roomInvitationRawPayload(%s)', roomInvitationId);
    }
    async roomInvitationRawPayloadParser(rawPayload) {
        log.verbose('PuppetXp', 'roomInvitationRawPayloadParser(%s)', JSON.stringify(rawPayload));
        return rawPayload;
    }
    /**
    *
    * Friendship
    *
    */
    async friendshipRawPayload(id) {
        return { id };
    }
    async friendshipRawPayloadParser(rawPayload) {
        return rawPayload;
    }
    async friendshipSearchPhone(phone) {
        log.verbose('PuppetXp', 'friendshipSearchPhone(%s)', phone);
        return null;
    }
    async friendshipSearchWeixin(weixin) {
        log.verbose('PuppetXp', 'friendshipSearchWeixin(%s)', weixin);
        return null;
    }
    async friendshipAdd(contactId, hello) {
        log.verbose('PuppetXp', 'friendshipAdd(%s, %s)', contactId, hello);
    }
    async friendshipAccept(friendshipId) {
        log.verbose('PuppetXp', 'friendshipAccept(%s)', friendshipId);
    }
    /**
    *
    * Tag
    *
    */
    async tagContactAdd(tagId, contactId) {
        log.verbose('PuppetXp', 'tagContactAdd(%s)', tagId, contactId);
    }
    async tagContactRemove(tagId, contactId) {
        log.verbose('PuppetXp', 'tagContactRemove(%s)', tagId, contactId);
    }
    async tagContactDelete(tagId) {
        log.verbose('PuppetXp', 'tagContactDelete(%s)', tagId);
    }
    async tagContactList(contactId) {
        log.verbose('PuppetXp', 'tagContactList(%s)', contactId);
        return [];
    }
}
_PuppetXp_sidecar = new WeakMap(), _PuppetXp_instances = new WeakSet(), _PuppetXp_tryStart = async function _PuppetXp_tryStart() {
    log.verbose('PuppetXp', '#tryStart()');
    if (__classPrivateFieldGet(this, _PuppetXp_sidecar, "f")) {
        // Huan(2021-09-13): need to call `detach` to make sure the sidecar will be closed?
        await detach(__classPrivateFieldGet(this, _PuppetXp_sidecar, "f"));
        __classPrivateFieldSet(this, _PuppetXp_sidecar, undefined, "f");
        log.warn('PuppetXp', '#tryStart() this.#sidecar exists? will be replaced by a new one.');
    }
    __classPrivateFieldSet(this, _PuppetXp_sidecar, new WeChatSidecar(), "f");
    await attach(this.sidecar);
    this.selfInfo = JSON.parse(await this.sidecar.getMyselfInfo());
    const contactList = JSON.parse(await this.sidecar.getContact());
    for (const contactKey in contactList) {
        const contactInfo = contactList[contactKey];
        const contact = {
            alias: '',
            avatar: '',
            friend: true,
            gender: ContactGender.Unknown,
            id: contactInfo.id,
            name: contactInfo.name,
            phone: [],
            type: ContactType.Unknown,
        };
        this.contactStore[contactInfo.id] = contact;
    }
    const roomList = JSON.parse(await this.sidecar.getChatroomMemberInfo());
    for (const roomKey in roomList) {
        const roomInfo = roomList[roomKey];
        const roomId = roomInfo.roomid;
        const roomMember = roomInfo.roomMember || [];
        const topic = this.contactStore[roomId]?.name || '';
        const room = {
            adminIdList: [],
            avatar: '',
            external: false,
            id: roomId,
            memberIdList: roomMember,
            ownerId: '',
            topic: topic,
        };
        this.roomStore[roomId] = room;
        for (const memberKey in roomMember) {
            const memberId = roomMember[memberKey];
            if (!this.contactStore[memberId]) {
                const memberNickName = await this.sidecar.getChatroomMemberNickInfo(memberId, roomId);
                const contact = {
                    alias: '',
                    avatar: '',
                    friend: false,
                    gender: ContactGender.Unknown,
                    id: memberId,
                    name: memberNickName,
                    phone: [],
                    type: ContactType.Unknown,
                };
                this.contactStore[memberId] = contact;
            }
        }
    }
    // console.debug(this.roomStore)
    // console.debug(this.contactStore)
    this.sidecar.on('hook', async ({ method, args }) => {
        if (method !== 'recvMsg') {
            return;
        }
        // console.info(args)
        let type = MessageType.Unknown;
        let roomId = '';
        let toId = '';
        let fromId = '';
        const text = String(args[2]);
        if (args[0] === 34) {
            type = MessageType.Audio;
        }
        else if (args[0] === 42) {
            type = MessageType.Contact;
        }
        else if (args[0] === 47) {
            type = MessageType.Emoticon;
        }
        else if (args[0] === 3) {
            type = MessageType.Image;
        }
        else if (args[0] === 1) {
            type = MessageType.Text;
        }
        else if (args[0] === 43) {
            type = MessageType.Video;
        }
        else {
            xml2js.parseString(text, { explicitArray: false, ignoreAttrs: true }, function (err, json) {
                console.info(err);
                console.info(JSON.stringify(json));
                if (json.msg.appmsg.type === 5) {
                    type = MessageType.Url;
                }
                else if (json.msg.appmsg.type === 33) {
                    type = MessageType.MiniProgram;
                }
                else if (json.msg.appmsg.type === 6) {
                    type = MessageType.Attachment;
                }
                else {
                    type = MessageType.Unknown;
                }
            });
        }
        if (String(args[1]).split('@').length !== 2) {
            fromId = String(args[1]);
            toId = this.selfInfo.id;
        }
        else {
            fromId = String(args[3]);
            roomId = String(args[1]);
        }
        const payload = {
            fromId,
            id: cuid(),
            roomId,
            text,
            timestamp: Date.now(),
            toId,
            type,
        };
        // console.info(payload)
        this.messageStore[payload.id] = payload;
        this.emit('message', { messageId: payload.id });
    });
    this.sidecar.on('error', e => this.emit('error', {
        message: e.message,
        name: e.name,
        stack: e.stack,
    }));
    // FIXME: use the real login contact id
    await this.login(this.selfInfo.id);
}, _PuppetXp_tryStop = async function _PuppetXp_tryStop() {
    log.verbose('PuppetXp', 'tryStop()');
    this.sidecar.removeAllListeners();
    if (this.logonoff()) {
        await this.logout();
    }
    await detach(this.sidecar);
    __classPrivateFieldSet(this, _PuppetXp_sidecar, undefined, "f");
};
PuppetXp.VERSION = VERSION;
export { PuppetXp };
export default PuppetXp;
//# sourceMappingURL=puppet-xp.js.map