"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Friendship_payload;
Object.defineProperty(exports, "__esModule", { value: true });
exports.wechatifyFriendship = exports.Friendship = void 0;
/**
 *   Wechaty Chatbot SDK - https://github.com/wechaty/wechaty
 *
 *   @copyright 2016 Huan LI (李卓桓) <https://github.com/huan>, and
 *                   Wechaty Contributors <https://github.com/wechaty>.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
const events_1 = require("events");
const wechaty_puppet_1 = require("wechaty-puppet");
const mod_js_1 = require("../helper-functions/mod.js");
const guard_wechatify_class_js_1 = require("./guard-wechatify-class.js");
/**
 * Send, receive friend request, and friend confirmation events.
 *
 * 1. send request
 * 2. receive request(in friend event)
 * 3. confirmation friendship(friend event)
 *
 * [Examples/Friend-Bot]{@link https://github.com/wechaty/wechaty/blob/1523c5e02be46ebe2cc172a744b2fbe53351540e/examples/friend-bot.ts}
 */
class Friendship extends events_1.EventEmitter {
    /*
     * @hideconstructor
     */
    constructor(id) {
        super();
        this.id = id;
        /**
         *
         * Instance Properties
         *
         */
        /**
          * @ignore
         */
        _Friendship_payload.set(this, void 0);
        wechaty_puppet_1.log.verbose('Friendship', 'constructor(id=%s)', id);
        guard_wechatify_class_js_1.guardWechatifyClass.call(this, Friendship);
    }
    static get wechaty() { return (0, guard_wechatify_class_js_1.throwWechatifyError)(this); }
    get wechaty() { return (0, guard_wechatify_class_js_1.throwWechatifyError)(this.constructor); }
    /**
     * @ignore
     */
    static load(id) {
        const newFriendship = new this(id);
        return newFriendship;
    }
    /**
     * Search a Friend by phone or weixin.
     *
     * The best practice is to search friend request once per minute.
     * Remember not to do this too frequently, or your account may be blocked.
     *
     * @param {FriendshipSearchCondition} condition - Search friend by phone or weixin.
     * @returns {Promise<Contact>}
     *
     * @example
     * const friend_phone = await bot.Friendship.search({phone: '13112341234'})
     * const friend_weixin = await bot.Friendship.search({weixin: 'weixin_account'})
     *
     * console.log(`This is the new friend info searched by phone : ${friend_phone}`)
     * await bot.Friendship.add(friend_phone, 'hello')
     *
     */
    static async search(queryFilter) {
        wechaty_puppet_1.log.verbose('Friendship', 'static search("%s")', JSON.stringify(queryFilter));
        const contactId = await this.wechaty.puppet.friendshipSearch(queryFilter);
        if (!contactId) {
            return null;
        }
        const contact = this.wechaty.Contact.load(contactId);
        await contact.ready();
        return contact;
    }
    /**
     * Send a Friend Request to a `contact` with message `hello`.
     *
     * The best practice is to send friend request once per minute.
     * Remeber not to do this too frequently, or your account may be blocked.
     *
     * @param {Contact} contact - Send friend request to contact
     * @param {FriendshipAddOptions} options - The friend request content
     * @returns {Promise<void>}
     *
     * @example
     * const contact = await bot.Friendship.search({phone: '13112341234'})
     * await bot.Friendship.add(contact, 'Nice to meet you! I am wechaty bot!')
     *
     * const memberList = await room.memberList()
     * for (let i = 0; i < memberList.length; i++) {
     *   await bot.Friendship.add(member, {
     *     room: room,
     *     hello: `Nice to meet you! I am wechaty bot from room: ${await room.topic()}!`,
     *   })
     * }
     *
     */
    static async add(contact, options) {
        wechaty_puppet_1.log.verbose('Friendship', 'static add(%s, %s)', contact.id, typeof options === 'string' ? options : options.hello);
        if (typeof options === 'string') {
            wechaty_puppet_1.log.warn('Friendship', 'the params hello is deprecated in the next version, please put the attr hello into options object, e.g. { hello: "xxxx" }');
            await this.wechaty.puppet.friendshipAdd(contact.id, { hello: options });
        }
        else {
            const friendOption = {
                contactId: options?.contact?.id,
                hello: options.hello,
                roomId: options.room && options.room.id,
            };
            await this.wechaty.puppet.friendshipAdd(contact.id, friendOption);
        }
    }
    static async del(contact) {
        wechaty_puppet_1.log.verbose('Friendship', 'static del(%s)', contact.id);
        throw new Error('to be implemented');
    }
    toString() {
        if (!__classPrivateFieldGet(this, _Friendship_payload, "f")) {
            return this.constructor.name;
        }
        return [
            'Friendship#',
            wechaty_puppet_1.FriendshipType[__classPrivateFieldGet(this, _Friendship_payload, "f").type],
            '<',
            __classPrivateFieldGet(this, _Friendship_payload, "f").contactId,
            '>',
        ].join('');
    }
    isReady() {
        return !!__classPrivateFieldGet(this, _Friendship_payload, "f") && (Object.keys(__classPrivateFieldGet(this, _Friendship_payload, "f")).length > 0);
    }
    /**
     * no `dirty` support because Friendship has no rawPayload(yet)
      * @ignore
     */
    async ready() {
        if (this.isReady()) {
            return;
        }
        __classPrivateFieldSet(this, _Friendship_payload, await this.wechaty.puppet.friendshipPayload(this.id), "f");
        if (!__classPrivateFieldGet(this, _Friendship_payload, "f")) {
            throw new Error('no payload');
        }
        await this.contact().ready();
    }
    /**
     * Accept Friend Request
     *
     * @returns {Promise<void>}
     *
     * @example
     * const bot = new Wechaty()
     * bot.on('friendship', async friendship => {
     *   try {
     *     console.log(`received friend event.`)
     *     switch (friendship.type()) {
     *
     *     // 1. New Friend Request
     *
     *     case Friendship.Type.Receive:
     *       await friendship.accept()
     *       break
     *
     *     // 2. Friend Ship Confirmed
     *
     *     case Friendship.Type.Confirm:
     *       console.log(`friend ship confirmed`)
     *       break
     *     }
     *   } catch (e) {
     *     console.error(e)
     *   }
     * }
     * .start()
     */
    async accept() {
        wechaty_puppet_1.log.verbose('Friendship', 'accept()');
        if (!__classPrivateFieldGet(this, _Friendship_payload, "f")) {
            throw new Error('no payload');
        }
        if (__classPrivateFieldGet(this, _Friendship_payload, "f").type !== Friendship.Type.Receive) {
            throw new Error('accept() need type to be FriendshipType.Receive, but it got a ' + Friendship.Type[__classPrivateFieldGet(this, _Friendship_payload, "f").type]);
        }
        wechaty_puppet_1.log.silly('Friendship', 'accept() to %s', __classPrivateFieldGet(this, _Friendship_payload, "f").contactId);
        await this.wechaty.puppet.friendshipAccept(this.id);
        const contact = this.contact();
        try {
            const doSync = async () => {
                await contact.ready();
                if (!contact.isReady()) {
                    throw new Error('Friendship.accept() contact.ready() not ready');
                }
                wechaty_puppet_1.log.verbose('Friendship', 'accept() with contact %s ready()', contact.name());
            };
            await mod_js_1.retryPolicy.execute(doSync);
        }
        catch (e) {
            wechaty_puppet_1.log.warn('Friendship', 'accept() contact %s not ready because of %s', contact, (e && e.message) || e);
            // console.error(e)
        }
        // try to fix issue #293 - https://github.com/wechaty/wechaty/issues/293
        await contact.sync();
    }
    /**
     * Get verify message from
     *
     * @returns {string}
     * @example <caption>If request content is `ding`, then accept the friendship</caption>
     * const bot = new Wechaty()
     * bot.on('friendship', async friendship => {
     *   try {
     *     console.log(`received friend event from ${friendship.contact().name()}`)
     *     if (friendship.type() === Friendship.Type.Receive && friendship.hello() === 'ding') {
     *       await friendship.accept()
     *     }
     *   } catch (e) {
     *     console.error(e)
     *   }
     * }
     * .start()
     */
    hello() {
        if (!__classPrivateFieldGet(this, _Friendship_payload, "f")) {
            throw new Error('no payload');
        }
        return __classPrivateFieldGet(this, _Friendship_payload, "f").hello || '';
    }
    /**
     * Get the contact from friendship
     *
     * @returns {Contact}
     * @example
     * const bot = new Wechaty()
     * bot.on('friendship', async friendship => {
     *   const contact = friendship.contact()
     *   const name = contact.name()
     *   console.log(`received friend event from ${name}`)
     * }
     * .start()
     */
    contact() {
        if (!__classPrivateFieldGet(this, _Friendship_payload, "f")) {
            throw new Error('no payload');
        }
        const contact = this.wechaty.Contact.load(__classPrivateFieldGet(this, _Friendship_payload, "f").contactId);
        return contact;
    }
    /**
     * Return the Friendship Type
     * > Tips: FriendshipType is enum here. </br>
     * - FriendshipType.Unknown  </br>
     * - FriendshipType.Confirm  </br>
     * - FriendshipType.Receive  </br>
     * - FriendshipType.Verify   </br>
     *
     * @returns {FriendshipType}
     *
     * @example <caption>If request content is `ding`, then accept the friendship</caption>
     * const bot = new Wechaty()
     * bot.on('friendship', async friendship => {
     *   try {
     *     if (friendship.type() === Friendship.Type.Receive && friendship.hello() === 'ding') {
     *       await friendship.accept()
     *     }
     *   } catch (e) {
     *     console.error(e)
     *   }
     * }
     * .start()
     */
    type() {
        return __classPrivateFieldGet(this, _Friendship_payload, "f")
            ? __classPrivateFieldGet(this, _Friendship_payload, "f").type
            : wechaty_puppet_1.FriendshipType.Unknown;
    }
    /**
     * get friendShipPayload Json
     * @returns {FriendshipPayload}
     *
     * @example
     * const bot = new Wechaty()
     * bot.on('friendship', async friendship => {
     *   try {
     *     // JSON.stringify(friendship) as well.
     *     const payload = await friendship.toJSON()
     *   } catch (e) {
     *     console.error(e)
     *   }
     * }
     * .start()
     */
    toJSON() {
        wechaty_puppet_1.log.verbose('Friendship', 'toJSON()');
        if (!this.isReady()) {
            throw new Error(`Friendship<${this.id}> needs to be ready. Please call ready() before toJSON()`);
        }
        return JSON.stringify(__classPrivateFieldGet(this, _Friendship_payload, "f"));
    }
    /**
     * create friendShip by friendshipJson
     * @example
     * const bot = new Wechaty()
     * bot.start()
     *
     * const payload = '{...}'  // your saved JSON payload
     * const friendship = bot.FriendShip.fromJSON(friendshipFromDisk)
     * await friendship.accept()
     */
    static async fromJSON(payload) {
        wechaty_puppet_1.log.verbose('Friendship', 'static fromJSON(%s)', typeof payload === 'string'
            ? payload
            : JSON.stringify(payload));
        if (typeof payload === 'string') {
            payload = JSON.parse(payload);
        }
        /**
         * Set the payload back to the puppet for future use
         */
        await this.wechaty.puppet.friendshipPayload(payload.id, payload);
        const instance = this.wechaty.Friendship.load(payload.id);
        await instance.ready();
        return instance;
    }
}
exports.Friendship = Friendship;
_Friendship_payload = new WeakMap();
Friendship.Type = wechaty_puppet_1.FriendshipType;
function wechatifyFriendship(wechaty) {
    wechaty_puppet_1.log.verbose('Friendship', 'wechatifyFriendship(%s)', wechaty);
    class WechatifiedFriendship extends Friendship {
        static get wechaty() { return wechaty; }
        get wechaty() { return wechaty; }
    }
    return WechatifiedFriendship;
}
exports.wechatifyFriendship = wechatifyFriendship;
//# sourceMappingURL=friendship.js.map