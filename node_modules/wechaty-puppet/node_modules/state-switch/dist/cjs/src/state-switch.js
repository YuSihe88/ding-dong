"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateSwitch = void 0;
/**
 *
 * StateSwitch for easy managing the states with async programming
 *
 * Class StateSwitch
 * Licenst: Apache-2.0
 * https://github.com/huan/state-switch
 *
 * Helper Class for Manage State Change
 */
const events_1 = require("events");
const nop_1 = __importDefault(require("nop"));
const version_js_1 = require("./version.js");
let COUNTER = 0;
class StateSwitch extends events_1.EventEmitter {
    constructor(name = `#${COUNTER++}`, options = {}) {
        super();
        this.name = name;
        this.options = options;
        if (options.log) {
            this.setLog(options.log);
        }
        else {
            this.setLog(null);
        }
        this.log.verbose('StateSwitch', 'constructor(%s, "%s")', name, JSON.stringify(options));
        this._onoff = false;
        this._pending = false;
        /**
         * for ready()
         */
        this.offPromise = Promise.resolve();
        this.onPromise = new Promise(resolve => {
            this.onResolver = resolve;
        });
        this.offResolver = nop_1.default;
    }
    /**
     * does the state is not stable(in process)?
     */
    get pending() {
        this.log.silly('StateSwitch', '<%s> pending() is %s', this.name, this._pending);
        return this._pending;
    }
    version() {
        return version_js_1.VERSION;
    }
    setLog(logInstance) {
        if (logInstance) {
            this.log = logInstance;
        }
        else {
            /* eslint @typescript-eslint/no-unused-vars: off */
            this.log = {
                error: nop_1.default,
                silly: nop_1.default,
                verbose: nop_1.default,
                warn: nop_1.default,
            };
        }
    }
    on(state) {
        /**
         * Set
         */
        if (state) {
            this.log.verbose('StateSwitch', '<%s> on(%s) <- (%s)', this.name, state, this.on());
            this._onoff = true;
            this._pending = (state === 'pending');
            this.emit('on', state);
            /**
              * for ready()
              */
            if (this.offResolver === nop_1.default) {
                this.offPromise = new Promise(resolve => (this.offResolver = resolve));
            }
            if (state === true && this.onResolver !== nop_1.default) {
                this.onResolver();
                this.onResolver = nop_1.default;
            }
            return;
        }
        /**
         * Get
         */
        const on = this._onoff
            ? this._pending
                ? 'pending'
                : true
            : false;
        this.log.silly('StateSwitch', '<%s> on() is %s', this.name, on);
        return on;
    }
    off(state) {
        /**
         * Set
         */
        if (state) {
            this.log.verbose('StateSwitch', '<%s> off(%s) <- (%s)', this.name, state, this.off());
            this._onoff = false;
            this._pending = (state === 'pending');
            this.emit('off', state);
            /**
              * for ready()
              */
            if (this.onResolver === nop_1.default) {
                this.onPromise = new Promise(resolve => (this.onResolver = resolve));
            }
            if (state === true && this.offResolver !== nop_1.default) {
                this.offResolver();
                this.offResolver = nop_1.default;
            }
            return;
        }
        /**
         * Get
         */
        const off = !this._onoff
            ? this._pending ? 'pending' : true
            : false;
        this.log.silly('StateSwitch', '<%s> off() is %s', this.name, off);
        return off;
    }
    async ready(state = 'on', noCross = false) {
        this.log.verbose('StateSwitch', '<%s> ready(%s, noCross=%s)', this.name, state, noCross);
        if (state === 'on') {
            if (this._onoff === false && noCross === true) {
                throw new Error('ready(on) but the state is off. call ready(on, false) to disable noCross');
            }
            await this.onPromise;
        }
        else if (state === 'off') {
            if (this._onoff === true && noCross === true) {
                throw new Error('ready(off) but the state is on. call ready(off, false) to disable noCross');
            }
            await this.offPromise;
        }
        else {
            throw new Error(`should not go here. ${state} should be of type 'never'`);
        }
        this.log.silly('StateSwitch', '<%s> ready(%s, %s) resolved.', this.name, state, noCross);
    }
    /**
     * Huan(202105): To make RxJS fromEvent happy: type inferencing
     *  https://github.com/ReactiveX/rxjs/blob/92fbdda7c06561bc73dae3c14de3fc7aff92bbd4/src/internal/observable/fromEvent.ts#L39-L50
     */
    addEventListener(event, listener) {
        if (listener) {
            super.addListener(event, listener);
        }
    }
    removeEventListener(event, listener) {
        if (listener) {
            super.removeListener(event, listener);
        }
    }
}
exports.StateSwitch = StateSwitch;
//# sourceMappingURL=state-switch.js.map